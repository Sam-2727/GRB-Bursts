#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Aug 17 17:43:45 2019

@author: samchristian
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from astropy.coordinates import SkyCoord
from astropy import units as u
from sklearn.metrics.pairwise import haversine_distances as haversine
import time
start_time = time.time()
c = SkyCoord('00:42.5 +41:12', unit=(u.hourangle, u.deg))
data = pd.read_csv(r'/Users/samchristian/Downloads/grb-updated2019.csv')
#print(type(data))
ras = data.loc[:, ['RA']]
decs = data.loc[:, ['Dec']]
redshifts = data.loc[:, ['Redshift']]
i = 0
num_in_range = 0
num_in_range2 = 0
num_in_range3 = 0
num_in_range4 = 0
output1_dec = []
output1_ra = []
output1 = []
while i < len(ras):
    #decs[i]
#    print(ras.iloc[i])
#    print(decs.iloc[i])
#    print(decs.iloc[i].values)
#    print(ras.iloc[i].values + decs.iloc[i].values)
    coord = SkyCoord((ras.iloc[i].values + decs.iloc[i].values), unit=(u.hourangle, u.deg))
    b = coord.galactic.b.deg
    dec1 = coord.dec.degree
    ra1 = coord.ra.degree
    if (redshifts.iloc[i].values <= 2.1 or redshifts.iloc[i].values >= 1.6):
        output1_dec.append(dec1)
        output1_ra.append(ra1)
        output1.append([ra1[0], dec1[0]])
    if ((b < 20 and b > -20) and (dec1 > 45 or dec1 < -45)):
        num_in_range += 1
    if (not(b < 20 and b > -20) and (dec1 > 45 or dec1 < -45)):
        num_in_range2 += 1
    if (not(b < 20 and b > -20) and not(dec1 > 45 or dec1 < -45)):
        num_in_range3 += 1
    if ((b < 20 and b > -20) and not(dec1 > 45 or dec1 < -45)):
        num_in_range4 += 1        
    i += 1
print(num_in_range)
print(num_in_range2)
print(num_in_range3)
print(num_in_range4)
data = data.loc[(data['Redshift'] <= 2.1) & (data['Redshift'] >= 1.6)] #upper bound comes first!. Removed zs1
print(len(data))
ras11 = data.loc[:, ['RA']]
decs11 = data.loc[:, ['Dec']]
DFoutput = pd.concat([ras11, decs11], axis = 1)
#print(ras)
#print(decs)
#zs = zs1[[zs1 <= 2.1]]
#zs = zs[zs1 >= 1.6]
#ras = ras1[[zs1 <= 2.1]]
#ras = ras[[[zs1 >= 1.6]]]
#decs = decs1[[zs1 <= 2.1]]
#decs = decs[[zs1 >= 1.6]]
ras_inrange = []
decs_inrange = []
def random_point_on_unit_sphere():
    while True:
        R   = np.random.rand(3) #Random point in box
        R   = 2*R - 1
        rsq = sum(R**2)
        if rsq < 1: break       #Use r only if |r|<1 in order not to favor corners of box
    return R / np.sqrt(rsq)     #Normalize to unit vector

def random_point_on_sky():
    dec = np.arcsin(np.random.random(1)*2-1)
    RA = np.random.random(1)*2*np.pi
    return [RA*180/np.pi, dec*180/np.pi]                                    #Many different formats are possible, e.g c.ra.hour for decimal hour values

def print_random_star_coords(nstars):
    dec = np.arcsin(np.random.random(1)*2-1)
    RA = np.random.random(1)*2*np.pi
    return [dec[0], RA[0]]
i = 0
ras1 = []
decs1 = []
print(len(ras11))
output1 = []
while i < len(ras11):
    #print(ras11.iloc[i].values[0])
    coord = SkyCoord((ras11.iloc[i].values + decs11.iloc[i].values), unit=(u.hourangle, u.deg))
    dec1 = coord.dec.degree
    ra1 = coord.ra.degree
    output1.append([ra1[0], dec1[0]])
    ras1.append(ra1)
    decs1.append(dec1)    
    i += 1
test_radii = 10000
i = 0
radius = 0.8953539
test_points = print_random_star_coords(test_radii)
#print(test_points)
num_in_distance = []
max_coords = []
print("here")
while i < test_radii:
    in_distance = []
    test_point = print_random_star_coords(1)
    max_coords.append(test_point)
    #print(test_point)
    #test_point = test_points[i]
    j = 0
    #print(test_point)
    while j < len(ras1):
        #print("j")
        #print(ras1)
        distance = haversine([test_point, [decs1[j]*np.pi/180, ras1[j]*np.pi/180]])
        #print(ras1.iloc[j], decs1.iloc[j])
        #print(distance)
        if distance[0][1] < radius:
            #print(distance[0][1])
            in_distance.append(1)
        j += 1
    num_in_distance.append(len(in_distance))
    i += 1
print(max(num_in_distance))
max_coord_index = num_in_distance.index(max(num_in_distance))
max_coord = max_coords[max_coord_index]
print(max_coord)
i = 0
coords_in_radius = []
while i < len(ras1):
    distance = haversine([max_coord, [decs1[i]*np.pi/180, ras1[i]*np.pi/180]])
    if distance[0][1] < radius:
        coords_in_radius.append([ras1[i][0], decs1[i][0]])
    i += 1
print(coords_in_radius)
#279.95833*np.pi/180 273.90467*np.pi/180
#print(1)
#print(len(ras1))
outputradius = pd.DataFrame.from_records(coords_in_radius)        
print("--- %s seconds ---" % (time.time() - start_time))
outputradius.to_csv('/Users/samchristian/Downloads/grb-outputinradius1.csv') #NOTE: With no number is the original. 1 is with the updated sample
outputTotal = pd.DataFrame.from_records(output1)
print(len(outputTotal))
outputTotal.to_csv('/Users/samchristian/Downloads/grb-outputTotal.csv')